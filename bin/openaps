#! /usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
"""
usage: openaps [--version] [--exec-path=<path>] [--html-path]
           [-p|--paginate|--no-pager] [--no-replace-objects]
           [--bare] [--openaps-dir=<path>] [--work-tree=<path>]
           [-c <name>=<value>] [--help]
           <command> [<args>...]

options:
   -c <name=value>
   -h, --help
   -p, --paginate

The most commonly used openaps commands are:
   get             Get a status report of some kind.
   suggest         Suggest a possible change to the environment.
   enact           Execute a suggestion.
   autocomplete    Print an autocompletion script
   branch          List, create, or delete branches
   checkout        Checkout a branch or paths to the working tree
   clone           Clone a repository into a new directory
   commit          Record changes to the repository
   push            Update remote refs along with associated objects
   remote          Manage set of tracked repositories

See 'openaps help <command>' for more information on a specific command.

"""
from subprocess import call

import sys, os
import argparse
import argcomplete
import openaps
from openaps import cli


def complete_args (prefix, parsed_args, action, **kwargs):
  # argcomplete.debug("parsed_args", parsed_args)
  compline = os.environ['COMP_LINE']
  argcomplete.debug("compline", compline)
  point = int(os.environ['COMP_POINT'])
  # argcomplete.debug("COMP_POINT", point)
  argcomplete.debug("parsed_args", parsed_args)
  if parsed_args.command is None:
    return [ ] or action.choices or ['init', 'alias', 'help', 'get', 'use', 'suggest', 'enact', 'device' ]
  # if True or parsed_args.command not in ['help', None]:
  # return [ 'debug' ]
  shell_cmd = ['openaps-%s' % parsed_args.command ] + parsed_args.args + [ prefix ]
  other_prog = shell_cmd[0]
  # point = len(parsed_args.command)
  # os.environ['COMP_POINT'] = str(point + len(' '.join([ ] + shell_cmd[2:])))
  old_name = compline.split(' ')
  compline = ' '.join([other_prog] + parsed_args.args + [ prefix ])
  os.environ['COMP_LINE'] = compline
  os.environ['COMP_POINT'] = str(len(compline))
  os.environ['PROGNAME'] = other_prog
  argcomplete.debug("subshell", shell_cmd, os.environ.keys( ))
  os.execvp(shell_cmd[0], shell_cmd[1:])
  sys.exit(0)

def no_complete (prefix, parsed_args, action, **kwargs):
  if parsed_args.command:
    return [ ]

from openaps import builtins
class BaseApp (cli.Base):
  """
  openaps - openaps: a toolkit for DIY artificial pancreas system

  Utilities for developing an artificial pancreas system.
  """
  always_complete_options = False
  def configure_parser (self, parser):
    self.parser.add_argument('-c', nargs=2).completer = no_complete
    self.parser.add_argument('-C', '--config', default=None).completer = no_complete
    self.parser.add_argument('--version', action='version', version='%s %s' % ('%(prog)s', openaps.__version__)).completer = no_complete
    self.parser.add_argument('command', nargs='?'
                            # , choices=['init', 'alias', 'help', 'get', 'suggest', 'enact' ]
                            , default=None).completer = complete_args
    self.parser.add_argument('args', nargs=argparse.REMAINDER).completer = complete_args

  def run (self, args):
    print self.inputs
    print args
    if args.config:
      os.environ['OPENAPS_CONFIG'] = args.config
    if args.command in ['help', None]:
      self.parser.print_help( )
    elif builtins.is_builtin(args.command):
      builtins.dispatch(args, self)
    elif args.command in ['get', 'suggest', ]:
      exit(call(['openaps-%s' % args.command ] + args.args))
    elif args.command:
      exit(call(['openaps-%s' % args.command ] + args.args))


if __name__ == '__main__':

    app = BaseApp(sys.argv)
    app( )
    sys.exit(0)

